// Code generated by protoc-gen-go-grpc. DO NOT EDIT.
// versions:
// - protoc-gen-go-grpc v1.5.1
// - protoc             v5.28.3
// source: asset.proto

package assetpb

import (
	context "context"
	grpc "google.golang.org/grpc"
	codes "google.golang.org/grpc/codes"
	status "google.golang.org/grpc/status"
)

// This is a compile-time assertion to ensure that this generated file
// is compatible with the grpc package it is being compiled against.
// Requires gRPC-Go v1.64.0 or later.
const _ = grpc.SupportPackageIsVersion9

const (
	SUBMISSIONService_CreateSubmission_FullMethodName       = "/asset.SUBMISSIONService/CreateSubmission"
	SUBMISSIONService_UpdateSubmissionStatus_FullMethodName = "/asset.SUBMISSIONService/UpdateSubmissionStatus"
)

// SUBMISSIONServiceClient is the client API for SUBMISSIONService service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
//
// All Services
type SUBMISSIONServiceClient interface {
	CreateSubmission(ctx context.Context, in *CreateSubmissionRequest, opts ...grpc.CallOption) (*CreateSubmissionResponse, error)
	UpdateSubmissionStatus(ctx context.Context, in *UpdateSubmissionStatusRequest, opts ...grpc.CallOption) (*UpdateSubmissionStatusResponse, error)
}

type sUBMISSIONServiceClient struct {
	cc grpc.ClientConnInterface
}

func NewSUBMISSIONServiceClient(cc grpc.ClientConnInterface) SUBMISSIONServiceClient {
	return &sUBMISSIONServiceClient{cc}
}

func (c *sUBMISSIONServiceClient) CreateSubmission(ctx context.Context, in *CreateSubmissionRequest, opts ...grpc.CallOption) (*CreateSubmissionResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(CreateSubmissionResponse)
	err := c.cc.Invoke(ctx, SUBMISSIONService_CreateSubmission_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *sUBMISSIONServiceClient) UpdateSubmissionStatus(ctx context.Context, in *UpdateSubmissionStatusRequest, opts ...grpc.CallOption) (*UpdateSubmissionStatusResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(UpdateSubmissionStatusResponse)
	err := c.cc.Invoke(ctx, SUBMISSIONService_UpdateSubmissionStatus_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// SUBMISSIONServiceServer is the server API for SUBMISSIONService service.
// All implementations must embed UnimplementedSUBMISSIONServiceServer
// for forward compatibility.
//
// All Services
type SUBMISSIONServiceServer interface {
	CreateSubmission(context.Context, *CreateSubmissionRequest) (*CreateSubmissionResponse, error)
	UpdateSubmissionStatus(context.Context, *UpdateSubmissionStatusRequest) (*UpdateSubmissionStatusResponse, error)
	mustEmbedUnimplementedSUBMISSIONServiceServer()
}

// UnimplementedSUBMISSIONServiceServer must be embedded to have
// forward compatible implementations.
//
// NOTE: this should be embedded by value instead of pointer to avoid a nil
// pointer dereference when methods are called.
type UnimplementedSUBMISSIONServiceServer struct{}

func (UnimplementedSUBMISSIONServiceServer) CreateSubmission(context.Context, *CreateSubmissionRequest) (*CreateSubmissionResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method CreateSubmission not implemented")
}
func (UnimplementedSUBMISSIONServiceServer) UpdateSubmissionStatus(context.Context, *UpdateSubmissionStatusRequest) (*UpdateSubmissionStatusResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method UpdateSubmissionStatus not implemented")
}
func (UnimplementedSUBMISSIONServiceServer) mustEmbedUnimplementedSUBMISSIONServiceServer() {}
func (UnimplementedSUBMISSIONServiceServer) testEmbeddedByValue()                           {}

// UnsafeSUBMISSIONServiceServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to SUBMISSIONServiceServer will
// result in compilation errors.
type UnsafeSUBMISSIONServiceServer interface {
	mustEmbedUnimplementedSUBMISSIONServiceServer()
}

func RegisterSUBMISSIONServiceServer(s grpc.ServiceRegistrar, srv SUBMISSIONServiceServer) {
	// If the following call pancis, it indicates UnimplementedSUBMISSIONServiceServer was
	// embedded by pointer and is nil.  This will cause panics if an
	// unimplemented method is ever invoked, so we test this at initialization
	// time to prevent it from happening at runtime later due to I/O.
	if t, ok := srv.(interface{ testEmbeddedByValue() }); ok {
		t.testEmbeddedByValue()
	}
	s.RegisterService(&SUBMISSIONService_ServiceDesc, srv)
}

func _SUBMISSIONService_CreateSubmission_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(CreateSubmissionRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(SUBMISSIONServiceServer).CreateSubmission(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: SUBMISSIONService_CreateSubmission_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(SUBMISSIONServiceServer).CreateSubmission(ctx, req.(*CreateSubmissionRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _SUBMISSIONService_UpdateSubmissionStatus_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(UpdateSubmissionStatusRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(SUBMISSIONServiceServer).UpdateSubmissionStatus(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: SUBMISSIONService_UpdateSubmissionStatus_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(SUBMISSIONServiceServer).UpdateSubmissionStatus(ctx, req.(*UpdateSubmissionStatusRequest))
	}
	return interceptor(ctx, in, info, handler)
}

// SUBMISSIONService_ServiceDesc is the grpc.ServiceDesc for SUBMISSIONService service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var SUBMISSIONService_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "asset.SUBMISSIONService",
	HandlerType: (*SUBMISSIONServiceServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "CreateSubmission",
			Handler:    _SUBMISSIONService_CreateSubmission_Handler,
		},
		{
			MethodName: "UpdateSubmissionStatus",
			Handler:    _SUBMISSIONService_UpdateSubmissionStatus_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "asset.proto",
}

const (
	MAINTENANCEPERIODService_ListMaintenancePeriod_FullMethodName   = "/asset.MAINTENANCEPERIODService/ListMaintenancePeriod"
	MAINTENANCEPERIODService_CreateMaintenancePeriod_FullMethodName = "/asset.MAINTENANCEPERIODService/CreateMaintenancePeriod"
)

// MAINTENANCEPERIODServiceClient is the client API for MAINTENANCEPERIODService service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
type MAINTENANCEPERIODServiceClient interface {
	ListMaintenancePeriod(ctx context.Context, in *ListMaintenancePeriodRequest, opts ...grpc.CallOption) (*ListMaintenancePeriodResponse, error)
	CreateMaintenancePeriod(ctx context.Context, in *CreateMaintenancePeriodRequest, opts ...grpc.CallOption) (*CreateMaintenancePeriodResponse, error)
}

type mAINTENANCEPERIODServiceClient struct {
	cc grpc.ClientConnInterface
}

func NewMAINTENANCEPERIODServiceClient(cc grpc.ClientConnInterface) MAINTENANCEPERIODServiceClient {
	return &mAINTENANCEPERIODServiceClient{cc}
}

func (c *mAINTENANCEPERIODServiceClient) ListMaintenancePeriod(ctx context.Context, in *ListMaintenancePeriodRequest, opts ...grpc.CallOption) (*ListMaintenancePeriodResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(ListMaintenancePeriodResponse)
	err := c.cc.Invoke(ctx, MAINTENANCEPERIODService_ListMaintenancePeriod_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *mAINTENANCEPERIODServiceClient) CreateMaintenancePeriod(ctx context.Context, in *CreateMaintenancePeriodRequest, opts ...grpc.CallOption) (*CreateMaintenancePeriodResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(CreateMaintenancePeriodResponse)
	err := c.cc.Invoke(ctx, MAINTENANCEPERIODService_CreateMaintenancePeriod_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// MAINTENANCEPERIODServiceServer is the server API for MAINTENANCEPERIODService service.
// All implementations must embed UnimplementedMAINTENANCEPERIODServiceServer
// for forward compatibility.
type MAINTENANCEPERIODServiceServer interface {
	ListMaintenancePeriod(context.Context, *ListMaintenancePeriodRequest) (*ListMaintenancePeriodResponse, error)
	CreateMaintenancePeriod(context.Context, *CreateMaintenancePeriodRequest) (*CreateMaintenancePeriodResponse, error)
	mustEmbedUnimplementedMAINTENANCEPERIODServiceServer()
}

// UnimplementedMAINTENANCEPERIODServiceServer must be embedded to have
// forward compatible implementations.
//
// NOTE: this should be embedded by value instead of pointer to avoid a nil
// pointer dereference when methods are called.
type UnimplementedMAINTENANCEPERIODServiceServer struct{}

func (UnimplementedMAINTENANCEPERIODServiceServer) ListMaintenancePeriod(context.Context, *ListMaintenancePeriodRequest) (*ListMaintenancePeriodResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ListMaintenancePeriod not implemented")
}
func (UnimplementedMAINTENANCEPERIODServiceServer) CreateMaintenancePeriod(context.Context, *CreateMaintenancePeriodRequest) (*CreateMaintenancePeriodResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method CreateMaintenancePeriod not implemented")
}
func (UnimplementedMAINTENANCEPERIODServiceServer) mustEmbedUnimplementedMAINTENANCEPERIODServiceServer() {
}
func (UnimplementedMAINTENANCEPERIODServiceServer) testEmbeddedByValue() {}

// UnsafeMAINTENANCEPERIODServiceServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to MAINTENANCEPERIODServiceServer will
// result in compilation errors.
type UnsafeMAINTENANCEPERIODServiceServer interface {
	mustEmbedUnimplementedMAINTENANCEPERIODServiceServer()
}

func RegisterMAINTENANCEPERIODServiceServer(s grpc.ServiceRegistrar, srv MAINTENANCEPERIODServiceServer) {
	// If the following call pancis, it indicates UnimplementedMAINTENANCEPERIODServiceServer was
	// embedded by pointer and is nil.  This will cause panics if an
	// unimplemented method is ever invoked, so we test this at initialization
	// time to prevent it from happening at runtime later due to I/O.
	if t, ok := srv.(interface{ testEmbeddedByValue() }); ok {
		t.testEmbeddedByValue()
	}
	s.RegisterService(&MAINTENANCEPERIODService_ServiceDesc, srv)
}

func _MAINTENANCEPERIODService_ListMaintenancePeriod_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ListMaintenancePeriodRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(MAINTENANCEPERIODServiceServer).ListMaintenancePeriod(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: MAINTENANCEPERIODService_ListMaintenancePeriod_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(MAINTENANCEPERIODServiceServer).ListMaintenancePeriod(ctx, req.(*ListMaintenancePeriodRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _MAINTENANCEPERIODService_CreateMaintenancePeriod_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(CreateMaintenancePeriodRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(MAINTENANCEPERIODServiceServer).CreateMaintenancePeriod(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: MAINTENANCEPERIODService_CreateMaintenancePeriod_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(MAINTENANCEPERIODServiceServer).CreateMaintenancePeriod(ctx, req.(*CreateMaintenancePeriodRequest))
	}
	return interceptor(ctx, in, info, handler)
}

// MAINTENANCEPERIODService_ServiceDesc is the grpc.ServiceDesc for MAINTENANCEPERIODService service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var MAINTENANCEPERIODService_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "asset.MAINTENANCEPERIODService",
	HandlerType: (*MAINTENANCEPERIODServiceServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "ListMaintenancePeriod",
			Handler:    _MAINTENANCEPERIODService_ListMaintenancePeriod_Handler,
		},
		{
			MethodName: "CreateMaintenancePeriod",
			Handler:    _MAINTENANCEPERIODService_CreateMaintenancePeriod_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "asset.proto",
}

const (
	CLASSIFICATIONService_ListClassification_FullMethodName   = "/asset.CLASSIFICATIONService/ListClassification"
	CLASSIFICATIONService_CreateClassification_FullMethodName = "/asset.CLASSIFICATIONService/CreateClassification"
	CLASSIFICATIONService_GetClassification_FullMethodName    = "/asset.CLASSIFICATIONService/GetClassification"
)

// CLASSIFICATIONServiceClient is the client API for CLASSIFICATIONService service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
type CLASSIFICATIONServiceClient interface {
	ListClassification(ctx context.Context, in *ListClassificationRequest, opts ...grpc.CallOption) (*ListClassificationResponse, error)
	CreateClassification(ctx context.Context, in *CreateClassificationRequest, opts ...grpc.CallOption) (*CreateClassificationResponse, error)
	GetClassification(ctx context.Context, in *GetClassificationRequest, opts ...grpc.CallOption) (*GetClassificationResponse, error)
}

type cLASSIFICATIONServiceClient struct {
	cc grpc.ClientConnInterface
}

func NewCLASSIFICATIONServiceClient(cc grpc.ClientConnInterface) CLASSIFICATIONServiceClient {
	return &cLASSIFICATIONServiceClient{cc}
}

func (c *cLASSIFICATIONServiceClient) ListClassification(ctx context.Context, in *ListClassificationRequest, opts ...grpc.CallOption) (*ListClassificationResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(ListClassificationResponse)
	err := c.cc.Invoke(ctx, CLASSIFICATIONService_ListClassification_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *cLASSIFICATIONServiceClient) CreateClassification(ctx context.Context, in *CreateClassificationRequest, opts ...grpc.CallOption) (*CreateClassificationResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(CreateClassificationResponse)
	err := c.cc.Invoke(ctx, CLASSIFICATIONService_CreateClassification_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *cLASSIFICATIONServiceClient) GetClassification(ctx context.Context, in *GetClassificationRequest, opts ...grpc.CallOption) (*GetClassificationResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(GetClassificationResponse)
	err := c.cc.Invoke(ctx, CLASSIFICATIONService_GetClassification_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// CLASSIFICATIONServiceServer is the server API for CLASSIFICATIONService service.
// All implementations must embed UnimplementedCLASSIFICATIONServiceServer
// for forward compatibility.
type CLASSIFICATIONServiceServer interface {
	ListClassification(context.Context, *ListClassificationRequest) (*ListClassificationResponse, error)
	CreateClassification(context.Context, *CreateClassificationRequest) (*CreateClassificationResponse, error)
	GetClassification(context.Context, *GetClassificationRequest) (*GetClassificationResponse, error)
	mustEmbedUnimplementedCLASSIFICATIONServiceServer()
}

// UnimplementedCLASSIFICATIONServiceServer must be embedded to have
// forward compatible implementations.
//
// NOTE: this should be embedded by value instead of pointer to avoid a nil
// pointer dereference when methods are called.
type UnimplementedCLASSIFICATIONServiceServer struct{}

func (UnimplementedCLASSIFICATIONServiceServer) ListClassification(context.Context, *ListClassificationRequest) (*ListClassificationResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ListClassification not implemented")
}
func (UnimplementedCLASSIFICATIONServiceServer) CreateClassification(context.Context, *CreateClassificationRequest) (*CreateClassificationResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method CreateClassification not implemented")
}
func (UnimplementedCLASSIFICATIONServiceServer) GetClassification(context.Context, *GetClassificationRequest) (*GetClassificationResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetClassification not implemented")
}
func (UnimplementedCLASSIFICATIONServiceServer) mustEmbedUnimplementedCLASSIFICATIONServiceServer() {}
func (UnimplementedCLASSIFICATIONServiceServer) testEmbeddedByValue()                               {}

// UnsafeCLASSIFICATIONServiceServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to CLASSIFICATIONServiceServer will
// result in compilation errors.
type UnsafeCLASSIFICATIONServiceServer interface {
	mustEmbedUnimplementedCLASSIFICATIONServiceServer()
}

func RegisterCLASSIFICATIONServiceServer(s grpc.ServiceRegistrar, srv CLASSIFICATIONServiceServer) {
	// If the following call pancis, it indicates UnimplementedCLASSIFICATIONServiceServer was
	// embedded by pointer and is nil.  This will cause panics if an
	// unimplemented method is ever invoked, so we test this at initialization
	// time to prevent it from happening at runtime later due to I/O.
	if t, ok := srv.(interface{ testEmbeddedByValue() }); ok {
		t.testEmbeddedByValue()
	}
	s.RegisterService(&CLASSIFICATIONService_ServiceDesc, srv)
}

func _CLASSIFICATIONService_ListClassification_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ListClassificationRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(CLASSIFICATIONServiceServer).ListClassification(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: CLASSIFICATIONService_ListClassification_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(CLASSIFICATIONServiceServer).ListClassification(ctx, req.(*ListClassificationRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _CLASSIFICATIONService_CreateClassification_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(CreateClassificationRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(CLASSIFICATIONServiceServer).CreateClassification(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: CLASSIFICATIONService_CreateClassification_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(CLASSIFICATIONServiceServer).CreateClassification(ctx, req.(*CreateClassificationRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _CLASSIFICATIONService_GetClassification_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetClassificationRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(CLASSIFICATIONServiceServer).GetClassification(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: CLASSIFICATIONService_GetClassification_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(CLASSIFICATIONServiceServer).GetClassification(ctx, req.(*GetClassificationRequest))
	}
	return interceptor(ctx, in, info, handler)
}

// CLASSIFICATIONService_ServiceDesc is the grpc.ServiceDesc for CLASSIFICATIONService service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var CLASSIFICATIONService_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "asset.CLASSIFICATIONService",
	HandlerType: (*CLASSIFICATIONServiceServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "ListClassification",
			Handler:    _CLASSIFICATIONService_ListClassification_Handler,
		},
		{
			MethodName: "CreateClassification",
			Handler:    _CLASSIFICATIONService_CreateClassification_Handler,
		},
		{
			MethodName: "GetClassification",
			Handler:    _CLASSIFICATIONService_GetClassification_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "asset.proto",
}

const (
	OUTLETService_ListOutlet_FullMethodName   = "/asset.OUTLETService/ListOutlet"
	OUTLETService_CreateOutlet_FullMethodName = "/asset.OUTLETService/CreateOutlet"
)

// OUTLETServiceClient is the client API for OUTLETService service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
type OUTLETServiceClient interface {
	ListOutlet(ctx context.Context, in *ListOutletRequest, opts ...grpc.CallOption) (*ListOutletResponse, error)
	CreateOutlet(ctx context.Context, in *CreateOutletRequest, opts ...grpc.CallOption) (*CreateOutletResponse, error)
}

type oUTLETServiceClient struct {
	cc grpc.ClientConnInterface
}

func NewOUTLETServiceClient(cc grpc.ClientConnInterface) OUTLETServiceClient {
	return &oUTLETServiceClient{cc}
}

func (c *oUTLETServiceClient) ListOutlet(ctx context.Context, in *ListOutletRequest, opts ...grpc.CallOption) (*ListOutletResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(ListOutletResponse)
	err := c.cc.Invoke(ctx, OUTLETService_ListOutlet_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *oUTLETServiceClient) CreateOutlet(ctx context.Context, in *CreateOutletRequest, opts ...grpc.CallOption) (*CreateOutletResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(CreateOutletResponse)
	err := c.cc.Invoke(ctx, OUTLETService_CreateOutlet_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// OUTLETServiceServer is the server API for OUTLETService service.
// All implementations must embed UnimplementedOUTLETServiceServer
// for forward compatibility.
type OUTLETServiceServer interface {
	ListOutlet(context.Context, *ListOutletRequest) (*ListOutletResponse, error)
	CreateOutlet(context.Context, *CreateOutletRequest) (*CreateOutletResponse, error)
	mustEmbedUnimplementedOUTLETServiceServer()
}

// UnimplementedOUTLETServiceServer must be embedded to have
// forward compatible implementations.
//
// NOTE: this should be embedded by value instead of pointer to avoid a nil
// pointer dereference when methods are called.
type UnimplementedOUTLETServiceServer struct{}

func (UnimplementedOUTLETServiceServer) ListOutlet(context.Context, *ListOutletRequest) (*ListOutletResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ListOutlet not implemented")
}
func (UnimplementedOUTLETServiceServer) CreateOutlet(context.Context, *CreateOutletRequest) (*CreateOutletResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method CreateOutlet not implemented")
}
func (UnimplementedOUTLETServiceServer) mustEmbedUnimplementedOUTLETServiceServer() {}
func (UnimplementedOUTLETServiceServer) testEmbeddedByValue()                       {}

// UnsafeOUTLETServiceServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to OUTLETServiceServer will
// result in compilation errors.
type UnsafeOUTLETServiceServer interface {
	mustEmbedUnimplementedOUTLETServiceServer()
}

func RegisterOUTLETServiceServer(s grpc.ServiceRegistrar, srv OUTLETServiceServer) {
	// If the following call pancis, it indicates UnimplementedOUTLETServiceServer was
	// embedded by pointer and is nil.  This will cause panics if an
	// unimplemented method is ever invoked, so we test this at initialization
	// time to prevent it from happening at runtime later due to I/O.
	if t, ok := srv.(interface{ testEmbeddedByValue() }); ok {
		t.testEmbeddedByValue()
	}
	s.RegisterService(&OUTLETService_ServiceDesc, srv)
}

func _OUTLETService_ListOutlet_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ListOutletRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(OUTLETServiceServer).ListOutlet(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: OUTLETService_ListOutlet_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(OUTLETServiceServer).ListOutlet(ctx, req.(*ListOutletRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _OUTLETService_CreateOutlet_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(CreateOutletRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(OUTLETServiceServer).CreateOutlet(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: OUTLETService_CreateOutlet_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(OUTLETServiceServer).CreateOutlet(ctx, req.(*CreateOutletRequest))
	}
	return interceptor(ctx, in, info, handler)
}

// OUTLETService_ServiceDesc is the grpc.ServiceDesc for OUTLETService service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var OUTLETService_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "asset.OUTLETService",
	HandlerType: (*OUTLETServiceServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "ListOutlet",
			Handler:    _OUTLETService_ListOutlet_Handler,
		},
		{
			MethodName: "CreateOutlet",
			Handler:    _OUTLETService_CreateOutlet_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "asset.proto",
}

const (
	AREAService_ListArea_FullMethodName   = "/asset.AREAService/ListArea"
	AREAService_CreateArea_FullMethodName = "/asset.AREAService/CreateArea"
)

// AREAServiceClient is the client API for AREAService service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
type AREAServiceClient interface {
	ListArea(ctx context.Context, in *ListAreaRequest, opts ...grpc.CallOption) (*ListAreaResponse, error)
	CreateArea(ctx context.Context, in *CreateAreaRequest, opts ...grpc.CallOption) (*CreateAreaResponse, error)
}

type aREAServiceClient struct {
	cc grpc.ClientConnInterface
}

func NewAREAServiceClient(cc grpc.ClientConnInterface) AREAServiceClient {
	return &aREAServiceClient{cc}
}

func (c *aREAServiceClient) ListArea(ctx context.Context, in *ListAreaRequest, opts ...grpc.CallOption) (*ListAreaResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(ListAreaResponse)
	err := c.cc.Invoke(ctx, AREAService_ListArea_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *aREAServiceClient) CreateArea(ctx context.Context, in *CreateAreaRequest, opts ...grpc.CallOption) (*CreateAreaResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(CreateAreaResponse)
	err := c.cc.Invoke(ctx, AREAService_CreateArea_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// AREAServiceServer is the server API for AREAService service.
// All implementations must embed UnimplementedAREAServiceServer
// for forward compatibility.
type AREAServiceServer interface {
	ListArea(context.Context, *ListAreaRequest) (*ListAreaResponse, error)
	CreateArea(context.Context, *CreateAreaRequest) (*CreateAreaResponse, error)
	mustEmbedUnimplementedAREAServiceServer()
}

// UnimplementedAREAServiceServer must be embedded to have
// forward compatible implementations.
//
// NOTE: this should be embedded by value instead of pointer to avoid a nil
// pointer dereference when methods are called.
type UnimplementedAREAServiceServer struct{}

func (UnimplementedAREAServiceServer) ListArea(context.Context, *ListAreaRequest) (*ListAreaResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ListArea not implemented")
}
func (UnimplementedAREAServiceServer) CreateArea(context.Context, *CreateAreaRequest) (*CreateAreaResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method CreateArea not implemented")
}
func (UnimplementedAREAServiceServer) mustEmbedUnimplementedAREAServiceServer() {}
func (UnimplementedAREAServiceServer) testEmbeddedByValue()                     {}

// UnsafeAREAServiceServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to AREAServiceServer will
// result in compilation errors.
type UnsafeAREAServiceServer interface {
	mustEmbedUnimplementedAREAServiceServer()
}

func RegisterAREAServiceServer(s grpc.ServiceRegistrar, srv AREAServiceServer) {
	// If the following call pancis, it indicates UnimplementedAREAServiceServer was
	// embedded by pointer and is nil.  This will cause panics if an
	// unimplemented method is ever invoked, so we test this at initialization
	// time to prevent it from happening at runtime later due to I/O.
	if t, ok := srv.(interface{ testEmbeddedByValue() }); ok {
		t.testEmbeddedByValue()
	}
	s.RegisterService(&AREAService_ServiceDesc, srv)
}

func _AREAService_ListArea_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ListAreaRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(AREAServiceServer).ListArea(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: AREAService_ListArea_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(AREAServiceServer).ListArea(ctx, req.(*ListAreaRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _AREAService_CreateArea_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(CreateAreaRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(AREAServiceServer).CreateArea(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: AREAService_CreateArea_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(AREAServiceServer).CreateArea(ctx, req.(*CreateAreaRequest))
	}
	return interceptor(ctx, in, info, handler)
}

// AREAService_ServiceDesc is the grpc.ServiceDesc for AREAService service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var AREAService_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "asset.AREAService",
	HandlerType: (*AREAServiceServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "ListArea",
			Handler:    _AREAService_ListArea_Handler,
		},
		{
			MethodName: "CreateArea",
			Handler:    _AREAService_CreateArea_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "asset.proto",
}

const (
	AUTHService_Login_FullMethodName  = "/asset.AUTHService/Login"
	AUTHService_Logout_FullMethodName = "/asset.AUTHService/Logout"
)

// AUTHServiceClient is the client API for AUTHService service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
type AUTHServiceClient interface {
	Login(ctx context.Context, in *LoginRequest, opts ...grpc.CallOption) (*LoginResponse, error)
	Logout(ctx context.Context, in *LogoutRequest, opts ...grpc.CallOption) (*LogoutResponse, error)
}

type aUTHServiceClient struct {
	cc grpc.ClientConnInterface
}

func NewAUTHServiceClient(cc grpc.ClientConnInterface) AUTHServiceClient {
	return &aUTHServiceClient{cc}
}

func (c *aUTHServiceClient) Login(ctx context.Context, in *LoginRequest, opts ...grpc.CallOption) (*LoginResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(LoginResponse)
	err := c.cc.Invoke(ctx, AUTHService_Login_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *aUTHServiceClient) Logout(ctx context.Context, in *LogoutRequest, opts ...grpc.CallOption) (*LogoutResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(LogoutResponse)
	err := c.cc.Invoke(ctx, AUTHService_Logout_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// AUTHServiceServer is the server API for AUTHService service.
// All implementations must embed UnimplementedAUTHServiceServer
// for forward compatibility.
type AUTHServiceServer interface {
	Login(context.Context, *LoginRequest) (*LoginResponse, error)
	Logout(context.Context, *LogoutRequest) (*LogoutResponse, error)
	mustEmbedUnimplementedAUTHServiceServer()
}

// UnimplementedAUTHServiceServer must be embedded to have
// forward compatible implementations.
//
// NOTE: this should be embedded by value instead of pointer to avoid a nil
// pointer dereference when methods are called.
type UnimplementedAUTHServiceServer struct{}

func (UnimplementedAUTHServiceServer) Login(context.Context, *LoginRequest) (*LoginResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Login not implemented")
}
func (UnimplementedAUTHServiceServer) Logout(context.Context, *LogoutRequest) (*LogoutResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Logout not implemented")
}
func (UnimplementedAUTHServiceServer) mustEmbedUnimplementedAUTHServiceServer() {}
func (UnimplementedAUTHServiceServer) testEmbeddedByValue()                     {}

// UnsafeAUTHServiceServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to AUTHServiceServer will
// result in compilation errors.
type UnsafeAUTHServiceServer interface {
	mustEmbedUnimplementedAUTHServiceServer()
}

func RegisterAUTHServiceServer(s grpc.ServiceRegistrar, srv AUTHServiceServer) {
	// If the following call pancis, it indicates UnimplementedAUTHServiceServer was
	// embedded by pointer and is nil.  This will cause panics if an
	// unimplemented method is ever invoked, so we test this at initialization
	// time to prevent it from happening at runtime later due to I/O.
	if t, ok := srv.(interface{ testEmbeddedByValue() }); ok {
		t.testEmbeddedByValue()
	}
	s.RegisterService(&AUTHService_ServiceDesc, srv)
}

func _AUTHService_Login_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(LoginRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(AUTHServiceServer).Login(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: AUTHService_Login_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(AUTHServiceServer).Login(ctx, req.(*LoginRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _AUTHService_Logout_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(LogoutRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(AUTHServiceServer).Logout(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: AUTHService_Logout_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(AUTHServiceServer).Logout(ctx, req.(*LogoutRequest))
	}
	return interceptor(ctx, in, info, handler)
}

// AUTHService_ServiceDesc is the grpc.ServiceDesc for AUTHService service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var AUTHService_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "asset.AUTHService",
	HandlerType: (*AUTHServiceServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "Login",
			Handler:    _AUTHService_Login_Handler,
		},
		{
			MethodName: "Logout",
			Handler:    _AUTHService_Logout_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "asset.proto",
}

const (
	ROLEService_ListRole_FullMethodName = "/asset.ROLEService/ListRole"
)

// ROLEServiceClient is the client API for ROLEService service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
type ROLEServiceClient interface {
	ListRole(ctx context.Context, in *ListRoleRequest, opts ...grpc.CallOption) (*ListRoleResponse, error)
}

type rOLEServiceClient struct {
	cc grpc.ClientConnInterface
}

func NewROLEServiceClient(cc grpc.ClientConnInterface) ROLEServiceClient {
	return &rOLEServiceClient{cc}
}

func (c *rOLEServiceClient) ListRole(ctx context.Context, in *ListRoleRequest, opts ...grpc.CallOption) (*ListRoleResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(ListRoleResponse)
	err := c.cc.Invoke(ctx, ROLEService_ListRole_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// ROLEServiceServer is the server API for ROLEService service.
// All implementations must embed UnimplementedROLEServiceServer
// for forward compatibility.
type ROLEServiceServer interface {
	ListRole(context.Context, *ListRoleRequest) (*ListRoleResponse, error)
	mustEmbedUnimplementedROLEServiceServer()
}

// UnimplementedROLEServiceServer must be embedded to have
// forward compatible implementations.
//
// NOTE: this should be embedded by value instead of pointer to avoid a nil
// pointer dereference when methods are called.
type UnimplementedROLEServiceServer struct{}

func (UnimplementedROLEServiceServer) ListRole(context.Context, *ListRoleRequest) (*ListRoleResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ListRole not implemented")
}
func (UnimplementedROLEServiceServer) mustEmbedUnimplementedROLEServiceServer() {}
func (UnimplementedROLEServiceServer) testEmbeddedByValue()                     {}

// UnsafeROLEServiceServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to ROLEServiceServer will
// result in compilation errors.
type UnsafeROLEServiceServer interface {
	mustEmbedUnimplementedROLEServiceServer()
}

func RegisterROLEServiceServer(s grpc.ServiceRegistrar, srv ROLEServiceServer) {
	// If the following call pancis, it indicates UnimplementedROLEServiceServer was
	// embedded by pointer and is nil.  This will cause panics if an
	// unimplemented method is ever invoked, so we test this at initialization
	// time to prevent it from happening at runtime later due to I/O.
	if t, ok := srv.(interface{ testEmbeddedByValue() }); ok {
		t.testEmbeddedByValue()
	}
	s.RegisterService(&ROLEService_ServiceDesc, srv)
}

func _ROLEService_ListRole_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ListRoleRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ROLEServiceServer).ListRole(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: ROLEService_ListRole_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ROLEServiceServer).ListRole(ctx, req.(*ListRoleRequest))
	}
	return interceptor(ctx, in, info, handler)
}

// ROLEService_ServiceDesc is the grpc.ServiceDesc for ROLEService service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var ROLEService_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "asset.ROLEService",
	HandlerType: (*ROLEServiceServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "ListRole",
			Handler:    _ROLEService_ListRole_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "asset.proto",
}

const (
	USERService_CreateUser_FullMethodName    = "/asset.USERService/CreateUser"
	USERService_GetUser_FullMethodName       = "/asset.USERService/GetUser"
	USERService_UpdateUser_FullMethodName    = "/asset.USERService/UpdateUser"
	USERService_DeleteUser_FullMethodName    = "/asset.USERService/DeleteUser"
	USERService_ListUsers_FullMethodName     = "/asset.USERService/ListUsers"
	USERService_ResetPassword_FullMethodName = "/asset.USERService/ResetPassword"
)

// USERServiceClient is the client API for USERService service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
type USERServiceClient interface {
	CreateUser(ctx context.Context, in *CreateUserRequest, opts ...grpc.CallOption) (*CreateUserResponse, error)
	GetUser(ctx context.Context, in *GetUserRequest, opts ...grpc.CallOption) (*GetUserResponse, error)
	UpdateUser(ctx context.Context, in *UpdateUserRequest, opts ...grpc.CallOption) (*UpdateUserResponse, error)
	DeleteUser(ctx context.Context, in *DeleteUserRequest, opts ...grpc.CallOption) (*DeleteUserResponse, error)
	ListUsers(ctx context.Context, in *ListUsersRequest, opts ...grpc.CallOption) (*ListUsersResponse, error)
	ResetPassword(ctx context.Context, in *ResetPasswordRequest, opts ...grpc.CallOption) (*ResetPasswordResponse, error)
}

type uSERServiceClient struct {
	cc grpc.ClientConnInterface
}

func NewUSERServiceClient(cc grpc.ClientConnInterface) USERServiceClient {
	return &uSERServiceClient{cc}
}

func (c *uSERServiceClient) CreateUser(ctx context.Context, in *CreateUserRequest, opts ...grpc.CallOption) (*CreateUserResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(CreateUserResponse)
	err := c.cc.Invoke(ctx, USERService_CreateUser_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *uSERServiceClient) GetUser(ctx context.Context, in *GetUserRequest, opts ...grpc.CallOption) (*GetUserResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(GetUserResponse)
	err := c.cc.Invoke(ctx, USERService_GetUser_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *uSERServiceClient) UpdateUser(ctx context.Context, in *UpdateUserRequest, opts ...grpc.CallOption) (*UpdateUserResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(UpdateUserResponse)
	err := c.cc.Invoke(ctx, USERService_UpdateUser_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *uSERServiceClient) DeleteUser(ctx context.Context, in *DeleteUserRequest, opts ...grpc.CallOption) (*DeleteUserResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(DeleteUserResponse)
	err := c.cc.Invoke(ctx, USERService_DeleteUser_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *uSERServiceClient) ListUsers(ctx context.Context, in *ListUsersRequest, opts ...grpc.CallOption) (*ListUsersResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(ListUsersResponse)
	err := c.cc.Invoke(ctx, USERService_ListUsers_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *uSERServiceClient) ResetPassword(ctx context.Context, in *ResetPasswordRequest, opts ...grpc.CallOption) (*ResetPasswordResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(ResetPasswordResponse)
	err := c.cc.Invoke(ctx, USERService_ResetPassword_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// USERServiceServer is the server API for USERService service.
// All implementations must embed UnimplementedUSERServiceServer
// for forward compatibility.
type USERServiceServer interface {
	CreateUser(context.Context, *CreateUserRequest) (*CreateUserResponse, error)
	GetUser(context.Context, *GetUserRequest) (*GetUserResponse, error)
	UpdateUser(context.Context, *UpdateUserRequest) (*UpdateUserResponse, error)
	DeleteUser(context.Context, *DeleteUserRequest) (*DeleteUserResponse, error)
	ListUsers(context.Context, *ListUsersRequest) (*ListUsersResponse, error)
	ResetPassword(context.Context, *ResetPasswordRequest) (*ResetPasswordResponse, error)
	mustEmbedUnimplementedUSERServiceServer()
}

// UnimplementedUSERServiceServer must be embedded to have
// forward compatible implementations.
//
// NOTE: this should be embedded by value instead of pointer to avoid a nil
// pointer dereference when methods are called.
type UnimplementedUSERServiceServer struct{}

func (UnimplementedUSERServiceServer) CreateUser(context.Context, *CreateUserRequest) (*CreateUserResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method CreateUser not implemented")
}
func (UnimplementedUSERServiceServer) GetUser(context.Context, *GetUserRequest) (*GetUserResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetUser not implemented")
}
func (UnimplementedUSERServiceServer) UpdateUser(context.Context, *UpdateUserRequest) (*UpdateUserResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method UpdateUser not implemented")
}
func (UnimplementedUSERServiceServer) DeleteUser(context.Context, *DeleteUserRequest) (*DeleteUserResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method DeleteUser not implemented")
}
func (UnimplementedUSERServiceServer) ListUsers(context.Context, *ListUsersRequest) (*ListUsersResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ListUsers not implemented")
}
func (UnimplementedUSERServiceServer) ResetPassword(context.Context, *ResetPasswordRequest) (*ResetPasswordResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ResetPassword not implemented")
}
func (UnimplementedUSERServiceServer) mustEmbedUnimplementedUSERServiceServer() {}
func (UnimplementedUSERServiceServer) testEmbeddedByValue()                     {}

// UnsafeUSERServiceServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to USERServiceServer will
// result in compilation errors.
type UnsafeUSERServiceServer interface {
	mustEmbedUnimplementedUSERServiceServer()
}

func RegisterUSERServiceServer(s grpc.ServiceRegistrar, srv USERServiceServer) {
	// If the following call pancis, it indicates UnimplementedUSERServiceServer was
	// embedded by pointer and is nil.  This will cause panics if an
	// unimplemented method is ever invoked, so we test this at initialization
	// time to prevent it from happening at runtime later due to I/O.
	if t, ok := srv.(interface{ testEmbeddedByValue() }); ok {
		t.testEmbeddedByValue()
	}
	s.RegisterService(&USERService_ServiceDesc, srv)
}

func _USERService_CreateUser_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(CreateUserRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(USERServiceServer).CreateUser(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: USERService_CreateUser_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(USERServiceServer).CreateUser(ctx, req.(*CreateUserRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _USERService_GetUser_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetUserRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(USERServiceServer).GetUser(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: USERService_GetUser_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(USERServiceServer).GetUser(ctx, req.(*GetUserRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _USERService_UpdateUser_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(UpdateUserRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(USERServiceServer).UpdateUser(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: USERService_UpdateUser_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(USERServiceServer).UpdateUser(ctx, req.(*UpdateUserRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _USERService_DeleteUser_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(DeleteUserRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(USERServiceServer).DeleteUser(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: USERService_DeleteUser_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(USERServiceServer).DeleteUser(ctx, req.(*DeleteUserRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _USERService_ListUsers_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ListUsersRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(USERServiceServer).ListUsers(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: USERService_ListUsers_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(USERServiceServer).ListUsers(ctx, req.(*ListUsersRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _USERService_ResetPassword_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ResetPasswordRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(USERServiceServer).ResetPassword(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: USERService_ResetPassword_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(USERServiceServer).ResetPassword(ctx, req.(*ResetPasswordRequest))
	}
	return interceptor(ctx, in, info, handler)
}

// USERService_ServiceDesc is the grpc.ServiceDesc for USERService service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var USERService_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "asset.USERService",
	HandlerType: (*USERServiceServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "CreateUser",
			Handler:    _USERService_CreateUser_Handler,
		},
		{
			MethodName: "GetUser",
			Handler:    _USERService_GetUser_Handler,
		},
		{
			MethodName: "UpdateUser",
			Handler:    _USERService_UpdateUser_Handler,
		},
		{
			MethodName: "DeleteUser",
			Handler:    _USERService_DeleteUser_Handler,
		},
		{
			MethodName: "ListUsers",
			Handler:    _USERService_ListUsers_Handler,
		},
		{
			MethodName: "ResetPassword",
			Handler:    _USERService_ResetPassword_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "asset.proto",
}

const (
	ASSETService_CreateAsset_FullMethodName       = "/asset.ASSETService/CreateAsset"
	ASSETService_GetAsset_FullMethodName          = "/asset.ASSETService/GetAsset"
	ASSETService_GetAssetByHash_FullMethodName    = "/asset.ASSETService/GetAssetByHash"
	ASSETService_UpdateAsset_FullMethodName       = "/asset.ASSETService/UpdateAsset"
	ASSETService_UpdateAssetStatus_FullMethodName = "/asset.ASSETService/UpdateAssetStatus"
	ASSETService_DeleteAsset_FullMethodName       = "/asset.ASSETService/DeleteAsset"
	ASSETService_ListAssets_FullMethodName        = "/asset.ASSETService/ListAssets"
)

// ASSETServiceClient is the client API for ASSETService service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
type ASSETServiceClient interface {
	CreateAsset(ctx context.Context, in *CreateAssetRequest, opts ...grpc.CallOption) (*CreateAssetResponse, error)
	GetAsset(ctx context.Context, in *GetAssetRequest, opts ...grpc.CallOption) (*GetAssetResponse, error)
	GetAssetByHash(ctx context.Context, in *GetAssetByHashRequest, opts ...grpc.CallOption) (*GetAssetByHashResponse, error)
	UpdateAsset(ctx context.Context, in *UpdateAssetRequest, opts ...grpc.CallOption) (*UpdateAssetResponse, error)
	UpdateAssetStatus(ctx context.Context, in *UpdateAssetStatusRequest, opts ...grpc.CallOption) (*UpdateAssetStatusResponse, error)
	DeleteAsset(ctx context.Context, in *DeleteAssetRequest, opts ...grpc.CallOption) (*DeleteAssetResponse, error)
	ListAssets(ctx context.Context, in *ListAssetsRequest, opts ...grpc.CallOption) (*ListAssetsResponse, error)
}

type aSSETServiceClient struct {
	cc grpc.ClientConnInterface
}

func NewASSETServiceClient(cc grpc.ClientConnInterface) ASSETServiceClient {
	return &aSSETServiceClient{cc}
}

func (c *aSSETServiceClient) CreateAsset(ctx context.Context, in *CreateAssetRequest, opts ...grpc.CallOption) (*CreateAssetResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(CreateAssetResponse)
	err := c.cc.Invoke(ctx, ASSETService_CreateAsset_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *aSSETServiceClient) GetAsset(ctx context.Context, in *GetAssetRequest, opts ...grpc.CallOption) (*GetAssetResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(GetAssetResponse)
	err := c.cc.Invoke(ctx, ASSETService_GetAsset_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *aSSETServiceClient) GetAssetByHash(ctx context.Context, in *GetAssetByHashRequest, opts ...grpc.CallOption) (*GetAssetByHashResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(GetAssetByHashResponse)
	err := c.cc.Invoke(ctx, ASSETService_GetAssetByHash_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *aSSETServiceClient) UpdateAsset(ctx context.Context, in *UpdateAssetRequest, opts ...grpc.CallOption) (*UpdateAssetResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(UpdateAssetResponse)
	err := c.cc.Invoke(ctx, ASSETService_UpdateAsset_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *aSSETServiceClient) UpdateAssetStatus(ctx context.Context, in *UpdateAssetStatusRequest, opts ...grpc.CallOption) (*UpdateAssetStatusResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(UpdateAssetStatusResponse)
	err := c.cc.Invoke(ctx, ASSETService_UpdateAssetStatus_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *aSSETServiceClient) DeleteAsset(ctx context.Context, in *DeleteAssetRequest, opts ...grpc.CallOption) (*DeleteAssetResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(DeleteAssetResponse)
	err := c.cc.Invoke(ctx, ASSETService_DeleteAsset_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *aSSETServiceClient) ListAssets(ctx context.Context, in *ListAssetsRequest, opts ...grpc.CallOption) (*ListAssetsResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(ListAssetsResponse)
	err := c.cc.Invoke(ctx, ASSETService_ListAssets_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// ASSETServiceServer is the server API for ASSETService service.
// All implementations must embed UnimplementedASSETServiceServer
// for forward compatibility.
type ASSETServiceServer interface {
	CreateAsset(context.Context, *CreateAssetRequest) (*CreateAssetResponse, error)
	GetAsset(context.Context, *GetAssetRequest) (*GetAssetResponse, error)
	GetAssetByHash(context.Context, *GetAssetByHashRequest) (*GetAssetByHashResponse, error)
	UpdateAsset(context.Context, *UpdateAssetRequest) (*UpdateAssetResponse, error)
	UpdateAssetStatus(context.Context, *UpdateAssetStatusRequest) (*UpdateAssetStatusResponse, error)
	DeleteAsset(context.Context, *DeleteAssetRequest) (*DeleteAssetResponse, error)
	ListAssets(context.Context, *ListAssetsRequest) (*ListAssetsResponse, error)
	mustEmbedUnimplementedASSETServiceServer()
}

// UnimplementedASSETServiceServer must be embedded to have
// forward compatible implementations.
//
// NOTE: this should be embedded by value instead of pointer to avoid a nil
// pointer dereference when methods are called.
type UnimplementedASSETServiceServer struct{}

func (UnimplementedASSETServiceServer) CreateAsset(context.Context, *CreateAssetRequest) (*CreateAssetResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method CreateAsset not implemented")
}
func (UnimplementedASSETServiceServer) GetAsset(context.Context, *GetAssetRequest) (*GetAssetResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetAsset not implemented")
}
func (UnimplementedASSETServiceServer) GetAssetByHash(context.Context, *GetAssetByHashRequest) (*GetAssetByHashResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetAssetByHash not implemented")
}
func (UnimplementedASSETServiceServer) UpdateAsset(context.Context, *UpdateAssetRequest) (*UpdateAssetResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method UpdateAsset not implemented")
}
func (UnimplementedASSETServiceServer) UpdateAssetStatus(context.Context, *UpdateAssetStatusRequest) (*UpdateAssetStatusResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method UpdateAssetStatus not implemented")
}
func (UnimplementedASSETServiceServer) DeleteAsset(context.Context, *DeleteAssetRequest) (*DeleteAssetResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method DeleteAsset not implemented")
}
func (UnimplementedASSETServiceServer) ListAssets(context.Context, *ListAssetsRequest) (*ListAssetsResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ListAssets not implemented")
}
func (UnimplementedASSETServiceServer) mustEmbedUnimplementedASSETServiceServer() {}
func (UnimplementedASSETServiceServer) testEmbeddedByValue()                      {}

// UnsafeASSETServiceServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to ASSETServiceServer will
// result in compilation errors.
type UnsafeASSETServiceServer interface {
	mustEmbedUnimplementedASSETServiceServer()
}

func RegisterASSETServiceServer(s grpc.ServiceRegistrar, srv ASSETServiceServer) {
	// If the following call pancis, it indicates UnimplementedASSETServiceServer was
	// embedded by pointer and is nil.  This will cause panics if an
	// unimplemented method is ever invoked, so we test this at initialization
	// time to prevent it from happening at runtime later due to I/O.
	if t, ok := srv.(interface{ testEmbeddedByValue() }); ok {
		t.testEmbeddedByValue()
	}
	s.RegisterService(&ASSETService_ServiceDesc, srv)
}

func _ASSETService_CreateAsset_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(CreateAssetRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ASSETServiceServer).CreateAsset(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: ASSETService_CreateAsset_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ASSETServiceServer).CreateAsset(ctx, req.(*CreateAssetRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _ASSETService_GetAsset_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetAssetRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ASSETServiceServer).GetAsset(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: ASSETService_GetAsset_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ASSETServiceServer).GetAsset(ctx, req.(*GetAssetRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _ASSETService_GetAssetByHash_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetAssetByHashRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ASSETServiceServer).GetAssetByHash(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: ASSETService_GetAssetByHash_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ASSETServiceServer).GetAssetByHash(ctx, req.(*GetAssetByHashRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _ASSETService_UpdateAsset_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(UpdateAssetRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ASSETServiceServer).UpdateAsset(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: ASSETService_UpdateAsset_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ASSETServiceServer).UpdateAsset(ctx, req.(*UpdateAssetRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _ASSETService_UpdateAssetStatus_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(UpdateAssetStatusRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ASSETServiceServer).UpdateAssetStatus(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: ASSETService_UpdateAssetStatus_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ASSETServiceServer).UpdateAssetStatus(ctx, req.(*UpdateAssetStatusRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _ASSETService_DeleteAsset_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(DeleteAssetRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ASSETServiceServer).DeleteAsset(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: ASSETService_DeleteAsset_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ASSETServiceServer).DeleteAsset(ctx, req.(*DeleteAssetRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _ASSETService_ListAssets_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ListAssetsRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ASSETServiceServer).ListAssets(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: ASSETService_ListAssets_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ASSETServiceServer).ListAssets(ctx, req.(*ListAssetsRequest))
	}
	return interceptor(ctx, in, info, handler)
}

// ASSETService_ServiceDesc is the grpc.ServiceDesc for ASSETService service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var ASSETService_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "asset.ASSETService",
	HandlerType: (*ASSETServiceServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "CreateAsset",
			Handler:    _ASSETService_CreateAsset_Handler,
		},
		{
			MethodName: "GetAsset",
			Handler:    _ASSETService_GetAsset_Handler,
		},
		{
			MethodName: "GetAssetByHash",
			Handler:    _ASSETService_GetAssetByHash_Handler,
		},
		{
			MethodName: "UpdateAsset",
			Handler:    _ASSETService_UpdateAsset_Handler,
		},
		{
			MethodName: "UpdateAssetStatus",
			Handler:    _ASSETService_UpdateAssetStatus_Handler,
		},
		{
			MethodName: "DeleteAsset",
			Handler:    _ASSETService_DeleteAsset_Handler,
		},
		{
			MethodName: "ListAssets",
			Handler:    _ASSETService_ListAssets_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "asset.proto",
}

const (
	ASSETUPDATEService_CreateAssetUpdate_FullMethodName = "/asset.ASSETUPDATEService/CreateAssetUpdate"
)

// ASSETUPDATEServiceClient is the client API for ASSETUPDATEService service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
type ASSETUPDATEServiceClient interface {
	CreateAssetUpdate(ctx context.Context, in *CreateAssetUpdateRequest, opts ...grpc.CallOption) (*CreateAssetUpdateResponse, error)
}

type aSSETUPDATEServiceClient struct {
	cc grpc.ClientConnInterface
}

func NewASSETUPDATEServiceClient(cc grpc.ClientConnInterface) ASSETUPDATEServiceClient {
	return &aSSETUPDATEServiceClient{cc}
}

func (c *aSSETUPDATEServiceClient) CreateAssetUpdate(ctx context.Context, in *CreateAssetUpdateRequest, opts ...grpc.CallOption) (*CreateAssetUpdateResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(CreateAssetUpdateResponse)
	err := c.cc.Invoke(ctx, ASSETUPDATEService_CreateAssetUpdate_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// ASSETUPDATEServiceServer is the server API for ASSETUPDATEService service.
// All implementations must embed UnimplementedASSETUPDATEServiceServer
// for forward compatibility.
type ASSETUPDATEServiceServer interface {
	CreateAssetUpdate(context.Context, *CreateAssetUpdateRequest) (*CreateAssetUpdateResponse, error)
	mustEmbedUnimplementedASSETUPDATEServiceServer()
}

// UnimplementedASSETUPDATEServiceServer must be embedded to have
// forward compatible implementations.
//
// NOTE: this should be embedded by value instead of pointer to avoid a nil
// pointer dereference when methods are called.
type UnimplementedASSETUPDATEServiceServer struct{}

func (UnimplementedASSETUPDATEServiceServer) CreateAssetUpdate(context.Context, *CreateAssetUpdateRequest) (*CreateAssetUpdateResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method CreateAssetUpdate not implemented")
}
func (UnimplementedASSETUPDATEServiceServer) mustEmbedUnimplementedASSETUPDATEServiceServer() {}
func (UnimplementedASSETUPDATEServiceServer) testEmbeddedByValue()                            {}

// UnsafeASSETUPDATEServiceServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to ASSETUPDATEServiceServer will
// result in compilation errors.
type UnsafeASSETUPDATEServiceServer interface {
	mustEmbedUnimplementedASSETUPDATEServiceServer()
}

func RegisterASSETUPDATEServiceServer(s grpc.ServiceRegistrar, srv ASSETUPDATEServiceServer) {
	// If the following call pancis, it indicates UnimplementedASSETUPDATEServiceServer was
	// embedded by pointer and is nil.  This will cause panics if an
	// unimplemented method is ever invoked, so we test this at initialization
	// time to prevent it from happening at runtime later due to I/O.
	if t, ok := srv.(interface{ testEmbeddedByValue() }); ok {
		t.testEmbeddedByValue()
	}
	s.RegisterService(&ASSETUPDATEService_ServiceDesc, srv)
}

func _ASSETUPDATEService_CreateAssetUpdate_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(CreateAssetUpdateRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ASSETUPDATEServiceServer).CreateAssetUpdate(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: ASSETUPDATEService_CreateAssetUpdate_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ASSETUPDATEServiceServer).CreateAssetUpdate(ctx, req.(*CreateAssetUpdateRequest))
	}
	return interceptor(ctx, in, info, handler)
}

// ASSETUPDATEService_ServiceDesc is the grpc.ServiceDesc for ASSETUPDATEService service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var ASSETUPDATEService_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "asset.ASSETUPDATEService",
	HandlerType: (*ASSETUPDATEServiceServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "CreateAssetUpdate",
			Handler:    _ASSETUPDATEService_CreateAssetUpdate_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "asset.proto",
}

const (
	PERSONALRESPONSIBLEService_ListPersonalResponsible_FullMethodName = "/asset.PERSONALRESPONSIBLEService/ListPersonalResponsible"
)

// PERSONALRESPONSIBLEServiceClient is the client API for PERSONALRESPONSIBLEService service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
type PERSONALRESPONSIBLEServiceClient interface {
	ListPersonalResponsible(ctx context.Context, in *ListPersonalResponsibleRequest, opts ...grpc.CallOption) (*ListPersonalResponsibleResponse, error)
}

type pERSONALRESPONSIBLEServiceClient struct {
	cc grpc.ClientConnInterface
}

func NewPERSONALRESPONSIBLEServiceClient(cc grpc.ClientConnInterface) PERSONALRESPONSIBLEServiceClient {
	return &pERSONALRESPONSIBLEServiceClient{cc}
}

func (c *pERSONALRESPONSIBLEServiceClient) ListPersonalResponsible(ctx context.Context, in *ListPersonalResponsibleRequest, opts ...grpc.CallOption) (*ListPersonalResponsibleResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(ListPersonalResponsibleResponse)
	err := c.cc.Invoke(ctx, PERSONALRESPONSIBLEService_ListPersonalResponsible_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// PERSONALRESPONSIBLEServiceServer is the server API for PERSONALRESPONSIBLEService service.
// All implementations must embed UnimplementedPERSONALRESPONSIBLEServiceServer
// for forward compatibility.
type PERSONALRESPONSIBLEServiceServer interface {
	ListPersonalResponsible(context.Context, *ListPersonalResponsibleRequest) (*ListPersonalResponsibleResponse, error)
	mustEmbedUnimplementedPERSONALRESPONSIBLEServiceServer()
}

// UnimplementedPERSONALRESPONSIBLEServiceServer must be embedded to have
// forward compatible implementations.
//
// NOTE: this should be embedded by value instead of pointer to avoid a nil
// pointer dereference when methods are called.
type UnimplementedPERSONALRESPONSIBLEServiceServer struct{}

func (UnimplementedPERSONALRESPONSIBLEServiceServer) ListPersonalResponsible(context.Context, *ListPersonalResponsibleRequest) (*ListPersonalResponsibleResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ListPersonalResponsible not implemented")
}
func (UnimplementedPERSONALRESPONSIBLEServiceServer) mustEmbedUnimplementedPERSONALRESPONSIBLEServiceServer() {
}
func (UnimplementedPERSONALRESPONSIBLEServiceServer) testEmbeddedByValue() {}

// UnsafePERSONALRESPONSIBLEServiceServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to PERSONALRESPONSIBLEServiceServer will
// result in compilation errors.
type UnsafePERSONALRESPONSIBLEServiceServer interface {
	mustEmbedUnimplementedPERSONALRESPONSIBLEServiceServer()
}

func RegisterPERSONALRESPONSIBLEServiceServer(s grpc.ServiceRegistrar, srv PERSONALRESPONSIBLEServiceServer) {
	// If the following call pancis, it indicates UnimplementedPERSONALRESPONSIBLEServiceServer was
	// embedded by pointer and is nil.  This will cause panics if an
	// unimplemented method is ever invoked, so we test this at initialization
	// time to prevent it from happening at runtime later due to I/O.
	if t, ok := srv.(interface{ testEmbeddedByValue() }); ok {
		t.testEmbeddedByValue()
	}
	s.RegisterService(&PERSONALRESPONSIBLEService_ServiceDesc, srv)
}

func _PERSONALRESPONSIBLEService_ListPersonalResponsible_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ListPersonalResponsibleRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(PERSONALRESPONSIBLEServiceServer).ListPersonalResponsible(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: PERSONALRESPONSIBLEService_ListPersonalResponsible_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(PERSONALRESPONSIBLEServiceServer).ListPersonalResponsible(ctx, req.(*ListPersonalResponsibleRequest))
	}
	return interceptor(ctx, in, info, handler)
}

// PERSONALRESPONSIBLEService_ServiceDesc is the grpc.ServiceDesc for PERSONALRESPONSIBLEService service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var PERSONALRESPONSIBLEService_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "asset.PERSONALRESPONSIBLEService",
	HandlerType: (*PERSONALRESPONSIBLEServiceServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "ListPersonalResponsible",
			Handler:    _PERSONALRESPONSIBLEService_ListPersonalResponsible_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "asset.proto",
}
