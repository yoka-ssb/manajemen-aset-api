// Code generated by protoc-gen-go-grpc. DO NOT EDIT.
// versions:
// - protoc-gen-go-grpc v1.5.1
// - protoc             v5.28.3
// source: asset.proto

package assetpb

import (
	context "context"
	grpc "google.golang.org/grpc"
	codes "google.golang.org/grpc/codes"
	status "google.golang.org/grpc/status"
)

// This is a compile-time assertion to ensure that this generated file
// is compatible with the grpc package it is being compiled against.
// Requires gRPC-Go v1.64.0 or later.
const _ = grpc.SupportPackageIsVersion9

const (
	OUTLETService_ListOutlet_FullMethodName   = "/asset.OUTLETService/ListOutlet"
	OUTLETService_CreateOutlet_FullMethodName = "/asset.OUTLETService/CreateOutlet"
)

// OUTLETServiceClient is the client API for OUTLETService service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
//
// Services
type OUTLETServiceClient interface {
	ListOutlet(ctx context.Context, in *ListOutletRequest, opts ...grpc.CallOption) (*ListOutletResponse, error)
	CreateOutlet(ctx context.Context, in *CreateOutletRequest, opts ...grpc.CallOption) (*CreateOutletResponse, error)
}

type oUTLETServiceClient struct {
	cc grpc.ClientConnInterface
}

func NewOUTLETServiceClient(cc grpc.ClientConnInterface) OUTLETServiceClient {
	return &oUTLETServiceClient{cc}
}

func (c *oUTLETServiceClient) ListOutlet(ctx context.Context, in *ListOutletRequest, opts ...grpc.CallOption) (*ListOutletResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(ListOutletResponse)
	err := c.cc.Invoke(ctx, OUTLETService_ListOutlet_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *oUTLETServiceClient) CreateOutlet(ctx context.Context, in *CreateOutletRequest, opts ...grpc.CallOption) (*CreateOutletResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(CreateOutletResponse)
	err := c.cc.Invoke(ctx, OUTLETService_CreateOutlet_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// OUTLETServiceServer is the server API for OUTLETService service.
// All implementations must embed UnimplementedOUTLETServiceServer
// for forward compatibility.
//
// Services
type OUTLETServiceServer interface {
	ListOutlet(context.Context, *ListOutletRequest) (*ListOutletResponse, error)
	CreateOutlet(context.Context, *CreateOutletRequest) (*CreateOutletResponse, error)
	mustEmbedUnimplementedOUTLETServiceServer()
}

// UnimplementedOUTLETServiceServer must be embedded to have
// forward compatible implementations.
//
// NOTE: this should be embedded by value instead of pointer to avoid a nil
// pointer dereference when methods are called.
type UnimplementedOUTLETServiceServer struct{}

func (UnimplementedOUTLETServiceServer) ListOutlet(context.Context, *ListOutletRequest) (*ListOutletResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ListOutlet not implemented")
}
func (UnimplementedOUTLETServiceServer) CreateOutlet(context.Context, *CreateOutletRequest) (*CreateOutletResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method CreateOutlet not implemented")
}
func (UnimplementedOUTLETServiceServer) mustEmbedUnimplementedOUTLETServiceServer() {}
func (UnimplementedOUTLETServiceServer) testEmbeddedByValue()                       {}

// UnsafeOUTLETServiceServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to OUTLETServiceServer will
// result in compilation errors.
type UnsafeOUTLETServiceServer interface {
	mustEmbedUnimplementedOUTLETServiceServer()
}

func RegisterOUTLETServiceServer(s grpc.ServiceRegistrar, srv OUTLETServiceServer) {
	// If the following call pancis, it indicates UnimplementedOUTLETServiceServer was
	// embedded by pointer and is nil.  This will cause panics if an
	// unimplemented method is ever invoked, so we test this at initialization
	// time to prevent it from happening at runtime later due to I/O.
	if t, ok := srv.(interface{ testEmbeddedByValue() }); ok {
		t.testEmbeddedByValue()
	}
	s.RegisterService(&OUTLETService_ServiceDesc, srv)
}

func _OUTLETService_ListOutlet_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ListOutletRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(OUTLETServiceServer).ListOutlet(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: OUTLETService_ListOutlet_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(OUTLETServiceServer).ListOutlet(ctx, req.(*ListOutletRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _OUTLETService_CreateOutlet_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(CreateOutletRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(OUTLETServiceServer).CreateOutlet(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: OUTLETService_CreateOutlet_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(OUTLETServiceServer).CreateOutlet(ctx, req.(*CreateOutletRequest))
	}
	return interceptor(ctx, in, info, handler)
}

// OUTLETService_ServiceDesc is the grpc.ServiceDesc for OUTLETService service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var OUTLETService_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "asset.OUTLETService",
	HandlerType: (*OUTLETServiceServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "ListOutlet",
			Handler:    _OUTLETService_ListOutlet_Handler,
		},
		{
			MethodName: "CreateOutlet",
			Handler:    _OUTLETService_CreateOutlet_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "asset.proto",
}

const (
	AREAService_ListArea_FullMethodName   = "/asset.AREAService/ListArea"
	AREAService_CreateArea_FullMethodName = "/asset.AREAService/CreateArea"
)

// AREAServiceClient is the client API for AREAService service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
type AREAServiceClient interface {
	ListArea(ctx context.Context, in *ListAreaRequest, opts ...grpc.CallOption) (*ListAreaResponse, error)
	CreateArea(ctx context.Context, in *CreateAreaRequest, opts ...grpc.CallOption) (*CreateAreaResponse, error)
}

type aREAServiceClient struct {
	cc grpc.ClientConnInterface
}

func NewAREAServiceClient(cc grpc.ClientConnInterface) AREAServiceClient {
	return &aREAServiceClient{cc}
}

func (c *aREAServiceClient) ListArea(ctx context.Context, in *ListAreaRequest, opts ...grpc.CallOption) (*ListAreaResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(ListAreaResponse)
	err := c.cc.Invoke(ctx, AREAService_ListArea_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *aREAServiceClient) CreateArea(ctx context.Context, in *CreateAreaRequest, opts ...grpc.CallOption) (*CreateAreaResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(CreateAreaResponse)
	err := c.cc.Invoke(ctx, AREAService_CreateArea_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// AREAServiceServer is the server API for AREAService service.
// All implementations must embed UnimplementedAREAServiceServer
// for forward compatibility.
type AREAServiceServer interface {
	ListArea(context.Context, *ListAreaRequest) (*ListAreaResponse, error)
	CreateArea(context.Context, *CreateAreaRequest) (*CreateAreaResponse, error)
	mustEmbedUnimplementedAREAServiceServer()
}

// UnimplementedAREAServiceServer must be embedded to have
// forward compatible implementations.
//
// NOTE: this should be embedded by value instead of pointer to avoid a nil
// pointer dereference when methods are called.
type UnimplementedAREAServiceServer struct{}

func (UnimplementedAREAServiceServer) ListArea(context.Context, *ListAreaRequest) (*ListAreaResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ListArea not implemented")
}
func (UnimplementedAREAServiceServer) CreateArea(context.Context, *CreateAreaRequest) (*CreateAreaResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method CreateArea not implemented")
}
func (UnimplementedAREAServiceServer) mustEmbedUnimplementedAREAServiceServer() {}
func (UnimplementedAREAServiceServer) testEmbeddedByValue()                     {}

// UnsafeAREAServiceServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to AREAServiceServer will
// result in compilation errors.
type UnsafeAREAServiceServer interface {
	mustEmbedUnimplementedAREAServiceServer()
}

func RegisterAREAServiceServer(s grpc.ServiceRegistrar, srv AREAServiceServer) {
	// If the following call pancis, it indicates UnimplementedAREAServiceServer was
	// embedded by pointer and is nil.  This will cause panics if an
	// unimplemented method is ever invoked, so we test this at initialization
	// time to prevent it from happening at runtime later due to I/O.
	if t, ok := srv.(interface{ testEmbeddedByValue() }); ok {
		t.testEmbeddedByValue()
	}
	s.RegisterService(&AREAService_ServiceDesc, srv)
}

func _AREAService_ListArea_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ListAreaRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(AREAServiceServer).ListArea(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: AREAService_ListArea_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(AREAServiceServer).ListArea(ctx, req.(*ListAreaRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _AREAService_CreateArea_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(CreateAreaRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(AREAServiceServer).CreateArea(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: AREAService_CreateArea_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(AREAServiceServer).CreateArea(ctx, req.(*CreateAreaRequest))
	}
	return interceptor(ctx, in, info, handler)
}

// AREAService_ServiceDesc is the grpc.ServiceDesc for AREAService service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var AREAService_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "asset.AREAService",
	HandlerType: (*AREAServiceServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "ListArea",
			Handler:    _AREAService_ListArea_Handler,
		},
		{
			MethodName: "CreateArea",
			Handler:    _AREAService_CreateArea_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "asset.proto",
}

const (
	AUTHService_Login_FullMethodName  = "/asset.AUTHService/Login"
	AUTHService_Logout_FullMethodName = "/asset.AUTHService/Logout"
)

// AUTHServiceClient is the client API for AUTHService service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
type AUTHServiceClient interface {
	Login(ctx context.Context, in *LoginRequest, opts ...grpc.CallOption) (*LoginResponse, error)
	Logout(ctx context.Context, in *LogoutRequest, opts ...grpc.CallOption) (*LogoutResponse, error)
}

type aUTHServiceClient struct {
	cc grpc.ClientConnInterface
}

func NewAUTHServiceClient(cc grpc.ClientConnInterface) AUTHServiceClient {
	return &aUTHServiceClient{cc}
}

func (c *aUTHServiceClient) Login(ctx context.Context, in *LoginRequest, opts ...grpc.CallOption) (*LoginResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(LoginResponse)
	err := c.cc.Invoke(ctx, AUTHService_Login_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *aUTHServiceClient) Logout(ctx context.Context, in *LogoutRequest, opts ...grpc.CallOption) (*LogoutResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(LogoutResponse)
	err := c.cc.Invoke(ctx, AUTHService_Logout_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// AUTHServiceServer is the server API for AUTHService service.
// All implementations must embed UnimplementedAUTHServiceServer
// for forward compatibility.
type AUTHServiceServer interface {
	Login(context.Context, *LoginRequest) (*LoginResponse, error)
	Logout(context.Context, *LogoutRequest) (*LogoutResponse, error)
	mustEmbedUnimplementedAUTHServiceServer()
}

// UnimplementedAUTHServiceServer must be embedded to have
// forward compatible implementations.
//
// NOTE: this should be embedded by value instead of pointer to avoid a nil
// pointer dereference when methods are called.
type UnimplementedAUTHServiceServer struct{}

func (UnimplementedAUTHServiceServer) Login(context.Context, *LoginRequest) (*LoginResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Login not implemented")
}
func (UnimplementedAUTHServiceServer) Logout(context.Context, *LogoutRequest) (*LogoutResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Logout not implemented")
}
func (UnimplementedAUTHServiceServer) mustEmbedUnimplementedAUTHServiceServer() {}
func (UnimplementedAUTHServiceServer) testEmbeddedByValue()                     {}

// UnsafeAUTHServiceServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to AUTHServiceServer will
// result in compilation errors.
type UnsafeAUTHServiceServer interface {
	mustEmbedUnimplementedAUTHServiceServer()
}

func RegisterAUTHServiceServer(s grpc.ServiceRegistrar, srv AUTHServiceServer) {
	// If the following call pancis, it indicates UnimplementedAUTHServiceServer was
	// embedded by pointer and is nil.  This will cause panics if an
	// unimplemented method is ever invoked, so we test this at initialization
	// time to prevent it from happening at runtime later due to I/O.
	if t, ok := srv.(interface{ testEmbeddedByValue() }); ok {
		t.testEmbeddedByValue()
	}
	s.RegisterService(&AUTHService_ServiceDesc, srv)
}

func _AUTHService_Login_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(LoginRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(AUTHServiceServer).Login(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: AUTHService_Login_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(AUTHServiceServer).Login(ctx, req.(*LoginRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _AUTHService_Logout_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(LogoutRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(AUTHServiceServer).Logout(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: AUTHService_Logout_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(AUTHServiceServer).Logout(ctx, req.(*LogoutRequest))
	}
	return interceptor(ctx, in, info, handler)
}

// AUTHService_ServiceDesc is the grpc.ServiceDesc for AUTHService service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var AUTHService_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "asset.AUTHService",
	HandlerType: (*AUTHServiceServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "Login",
			Handler:    _AUTHService_Login_Handler,
		},
		{
			MethodName: "Logout",
			Handler:    _AUTHService_Logout_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "asset.proto",
}

const (
	USERService_CreateUser_FullMethodName    = "/asset.USERService/CreateUser"
	USERService_GetUser_FullMethodName       = "/asset.USERService/GetUser"
	USERService_UpdateUser_FullMethodName    = "/asset.USERService/UpdateUser"
	USERService_DeleteUser_FullMethodName    = "/asset.USERService/DeleteUser"
	USERService_ListUsers_FullMethodName     = "/asset.USERService/ListUsers"
	USERService_ResetPassword_FullMethodName = "/asset.USERService/ResetPassword"
)

// USERServiceClient is the client API for USERService service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
type USERServiceClient interface {
	CreateUser(ctx context.Context, in *CreateUserRequest, opts ...grpc.CallOption) (*CreateUserResponse, error)
	GetUser(ctx context.Context, in *GetUserRequest, opts ...grpc.CallOption) (*GetUserResponse, error)
	UpdateUser(ctx context.Context, in *UpdateUserRequest, opts ...grpc.CallOption) (*UpdateUserResponse, error)
	DeleteUser(ctx context.Context, in *DeleteUserRequest, opts ...grpc.CallOption) (*DeleteUserResponse, error)
	ListUsers(ctx context.Context, in *ListUsersRequest, opts ...grpc.CallOption) (*ListUsersResponse, error)
	ResetPassword(ctx context.Context, in *ResetPasswordRequest, opts ...grpc.CallOption) (*ResetPasswordResponse, error)
}

type uSERServiceClient struct {
	cc grpc.ClientConnInterface
}

func NewUSERServiceClient(cc grpc.ClientConnInterface) USERServiceClient {
	return &uSERServiceClient{cc}
}

func (c *uSERServiceClient) CreateUser(ctx context.Context, in *CreateUserRequest, opts ...grpc.CallOption) (*CreateUserResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(CreateUserResponse)
	err := c.cc.Invoke(ctx, USERService_CreateUser_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *uSERServiceClient) GetUser(ctx context.Context, in *GetUserRequest, opts ...grpc.CallOption) (*GetUserResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(GetUserResponse)
	err := c.cc.Invoke(ctx, USERService_GetUser_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *uSERServiceClient) UpdateUser(ctx context.Context, in *UpdateUserRequest, opts ...grpc.CallOption) (*UpdateUserResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(UpdateUserResponse)
	err := c.cc.Invoke(ctx, USERService_UpdateUser_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *uSERServiceClient) DeleteUser(ctx context.Context, in *DeleteUserRequest, opts ...grpc.CallOption) (*DeleteUserResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(DeleteUserResponse)
	err := c.cc.Invoke(ctx, USERService_DeleteUser_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *uSERServiceClient) ListUsers(ctx context.Context, in *ListUsersRequest, opts ...grpc.CallOption) (*ListUsersResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(ListUsersResponse)
	err := c.cc.Invoke(ctx, USERService_ListUsers_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *uSERServiceClient) ResetPassword(ctx context.Context, in *ResetPasswordRequest, opts ...grpc.CallOption) (*ResetPasswordResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(ResetPasswordResponse)
	err := c.cc.Invoke(ctx, USERService_ResetPassword_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// USERServiceServer is the server API for USERService service.
// All implementations must embed UnimplementedUSERServiceServer
// for forward compatibility.
type USERServiceServer interface {
	CreateUser(context.Context, *CreateUserRequest) (*CreateUserResponse, error)
	GetUser(context.Context, *GetUserRequest) (*GetUserResponse, error)
	UpdateUser(context.Context, *UpdateUserRequest) (*UpdateUserResponse, error)
	DeleteUser(context.Context, *DeleteUserRequest) (*DeleteUserResponse, error)
	ListUsers(context.Context, *ListUsersRequest) (*ListUsersResponse, error)
	ResetPassword(context.Context, *ResetPasswordRequest) (*ResetPasswordResponse, error)
	mustEmbedUnimplementedUSERServiceServer()
}

// UnimplementedUSERServiceServer must be embedded to have
// forward compatible implementations.
//
// NOTE: this should be embedded by value instead of pointer to avoid a nil
// pointer dereference when methods are called.
type UnimplementedUSERServiceServer struct{}

func (UnimplementedUSERServiceServer) CreateUser(context.Context, *CreateUserRequest) (*CreateUserResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method CreateUser not implemented")
}
func (UnimplementedUSERServiceServer) GetUser(context.Context, *GetUserRequest) (*GetUserResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetUser not implemented")
}
func (UnimplementedUSERServiceServer) UpdateUser(context.Context, *UpdateUserRequest) (*UpdateUserResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method UpdateUser not implemented")
}
func (UnimplementedUSERServiceServer) DeleteUser(context.Context, *DeleteUserRequest) (*DeleteUserResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method DeleteUser not implemented")
}
func (UnimplementedUSERServiceServer) ListUsers(context.Context, *ListUsersRequest) (*ListUsersResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ListUsers not implemented")
}
func (UnimplementedUSERServiceServer) ResetPassword(context.Context, *ResetPasswordRequest) (*ResetPasswordResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ResetPassword not implemented")
}
func (UnimplementedUSERServiceServer) mustEmbedUnimplementedUSERServiceServer() {}
func (UnimplementedUSERServiceServer) testEmbeddedByValue()                     {}

// UnsafeUSERServiceServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to USERServiceServer will
// result in compilation errors.
type UnsafeUSERServiceServer interface {
	mustEmbedUnimplementedUSERServiceServer()
}

func RegisterUSERServiceServer(s grpc.ServiceRegistrar, srv USERServiceServer) {
	// If the following call pancis, it indicates UnimplementedUSERServiceServer was
	// embedded by pointer and is nil.  This will cause panics if an
	// unimplemented method is ever invoked, so we test this at initialization
	// time to prevent it from happening at runtime later due to I/O.
	if t, ok := srv.(interface{ testEmbeddedByValue() }); ok {
		t.testEmbeddedByValue()
	}
	s.RegisterService(&USERService_ServiceDesc, srv)
}

func _USERService_CreateUser_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(CreateUserRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(USERServiceServer).CreateUser(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: USERService_CreateUser_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(USERServiceServer).CreateUser(ctx, req.(*CreateUserRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _USERService_GetUser_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetUserRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(USERServiceServer).GetUser(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: USERService_GetUser_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(USERServiceServer).GetUser(ctx, req.(*GetUserRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _USERService_UpdateUser_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(UpdateUserRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(USERServiceServer).UpdateUser(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: USERService_UpdateUser_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(USERServiceServer).UpdateUser(ctx, req.(*UpdateUserRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _USERService_DeleteUser_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(DeleteUserRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(USERServiceServer).DeleteUser(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: USERService_DeleteUser_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(USERServiceServer).DeleteUser(ctx, req.(*DeleteUserRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _USERService_ListUsers_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ListUsersRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(USERServiceServer).ListUsers(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: USERService_ListUsers_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(USERServiceServer).ListUsers(ctx, req.(*ListUsersRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _USERService_ResetPassword_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ResetPasswordRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(USERServiceServer).ResetPassword(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: USERService_ResetPassword_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(USERServiceServer).ResetPassword(ctx, req.(*ResetPasswordRequest))
	}
	return interceptor(ctx, in, info, handler)
}

// USERService_ServiceDesc is the grpc.ServiceDesc for USERService service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var USERService_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "asset.USERService",
	HandlerType: (*USERServiceServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "CreateUser",
			Handler:    _USERService_CreateUser_Handler,
		},
		{
			MethodName: "GetUser",
			Handler:    _USERService_GetUser_Handler,
		},
		{
			MethodName: "UpdateUser",
			Handler:    _USERService_UpdateUser_Handler,
		},
		{
			MethodName: "DeleteUser",
			Handler:    _USERService_DeleteUser_Handler,
		},
		{
			MethodName: "ListUsers",
			Handler:    _USERService_ListUsers_Handler,
		},
		{
			MethodName: "ResetPassword",
			Handler:    _USERService_ResetPassword_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "asset.proto",
}

const (
	ASSETService_CreateItem_FullMethodName = "/asset.ASSETService/CreateItem"
	ASSETService_GetItem_FullMethodName    = "/asset.ASSETService/GetItem"
	ASSETService_UpdateItem_FullMethodName = "/asset.ASSETService/UpdateItem"
	ASSETService_DeleteItem_FullMethodName = "/asset.ASSETService/DeleteItem"
	ASSETService_ListItems_FullMethodName  = "/asset.ASSETService/ListItems"
)

// ASSETServiceClient is the client API for ASSETService service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
type ASSETServiceClient interface {
	CreateItem(ctx context.Context, in *CreateItemRequest, opts ...grpc.CallOption) (*CreateItemResponse, error)
	GetItem(ctx context.Context, in *GetItemRequest, opts ...grpc.CallOption) (*GetItemResponse, error)
	UpdateItem(ctx context.Context, in *UpdateItemRequest, opts ...grpc.CallOption) (*UpdateItemResponse, error)
	DeleteItem(ctx context.Context, in *DeleteItemRequest, opts ...grpc.CallOption) (*DeleteItemResponse, error)
	ListItems(ctx context.Context, in *ListItemsRequest, opts ...grpc.CallOption) (*ListItemsResponse, error)
}

type aSSETServiceClient struct {
	cc grpc.ClientConnInterface
}

func NewASSETServiceClient(cc grpc.ClientConnInterface) ASSETServiceClient {
	return &aSSETServiceClient{cc}
}

func (c *aSSETServiceClient) CreateItem(ctx context.Context, in *CreateItemRequest, opts ...grpc.CallOption) (*CreateItemResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(CreateItemResponse)
	err := c.cc.Invoke(ctx, ASSETService_CreateItem_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *aSSETServiceClient) GetItem(ctx context.Context, in *GetItemRequest, opts ...grpc.CallOption) (*GetItemResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(GetItemResponse)
	err := c.cc.Invoke(ctx, ASSETService_GetItem_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *aSSETServiceClient) UpdateItem(ctx context.Context, in *UpdateItemRequest, opts ...grpc.CallOption) (*UpdateItemResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(UpdateItemResponse)
	err := c.cc.Invoke(ctx, ASSETService_UpdateItem_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *aSSETServiceClient) DeleteItem(ctx context.Context, in *DeleteItemRequest, opts ...grpc.CallOption) (*DeleteItemResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(DeleteItemResponse)
	err := c.cc.Invoke(ctx, ASSETService_DeleteItem_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *aSSETServiceClient) ListItems(ctx context.Context, in *ListItemsRequest, opts ...grpc.CallOption) (*ListItemsResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(ListItemsResponse)
	err := c.cc.Invoke(ctx, ASSETService_ListItems_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// ASSETServiceServer is the server API for ASSETService service.
// All implementations must embed UnimplementedASSETServiceServer
// for forward compatibility.
type ASSETServiceServer interface {
	CreateItem(context.Context, *CreateItemRequest) (*CreateItemResponse, error)
	GetItem(context.Context, *GetItemRequest) (*GetItemResponse, error)
	UpdateItem(context.Context, *UpdateItemRequest) (*UpdateItemResponse, error)
	DeleteItem(context.Context, *DeleteItemRequest) (*DeleteItemResponse, error)
	ListItems(context.Context, *ListItemsRequest) (*ListItemsResponse, error)
	mustEmbedUnimplementedASSETServiceServer()
}

// UnimplementedASSETServiceServer must be embedded to have
// forward compatible implementations.
//
// NOTE: this should be embedded by value instead of pointer to avoid a nil
// pointer dereference when methods are called.
type UnimplementedASSETServiceServer struct{}

func (UnimplementedASSETServiceServer) CreateItem(context.Context, *CreateItemRequest) (*CreateItemResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method CreateItem not implemented")
}
func (UnimplementedASSETServiceServer) GetItem(context.Context, *GetItemRequest) (*GetItemResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetItem not implemented")
}
func (UnimplementedASSETServiceServer) UpdateItem(context.Context, *UpdateItemRequest) (*UpdateItemResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method UpdateItem not implemented")
}
func (UnimplementedASSETServiceServer) DeleteItem(context.Context, *DeleteItemRequest) (*DeleteItemResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method DeleteItem not implemented")
}
func (UnimplementedASSETServiceServer) ListItems(context.Context, *ListItemsRequest) (*ListItemsResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ListItems not implemented")
}
func (UnimplementedASSETServiceServer) mustEmbedUnimplementedASSETServiceServer() {}
func (UnimplementedASSETServiceServer) testEmbeddedByValue()                      {}

// UnsafeASSETServiceServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to ASSETServiceServer will
// result in compilation errors.
type UnsafeASSETServiceServer interface {
	mustEmbedUnimplementedASSETServiceServer()
}

func RegisterASSETServiceServer(s grpc.ServiceRegistrar, srv ASSETServiceServer) {
	// If the following call pancis, it indicates UnimplementedASSETServiceServer was
	// embedded by pointer and is nil.  This will cause panics if an
	// unimplemented method is ever invoked, so we test this at initialization
	// time to prevent it from happening at runtime later due to I/O.
	if t, ok := srv.(interface{ testEmbeddedByValue() }); ok {
		t.testEmbeddedByValue()
	}
	s.RegisterService(&ASSETService_ServiceDesc, srv)
}

func _ASSETService_CreateItem_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(CreateItemRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ASSETServiceServer).CreateItem(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: ASSETService_CreateItem_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ASSETServiceServer).CreateItem(ctx, req.(*CreateItemRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _ASSETService_GetItem_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetItemRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ASSETServiceServer).GetItem(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: ASSETService_GetItem_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ASSETServiceServer).GetItem(ctx, req.(*GetItemRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _ASSETService_UpdateItem_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(UpdateItemRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ASSETServiceServer).UpdateItem(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: ASSETService_UpdateItem_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ASSETServiceServer).UpdateItem(ctx, req.(*UpdateItemRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _ASSETService_DeleteItem_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(DeleteItemRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ASSETServiceServer).DeleteItem(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: ASSETService_DeleteItem_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ASSETServiceServer).DeleteItem(ctx, req.(*DeleteItemRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _ASSETService_ListItems_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ListItemsRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ASSETServiceServer).ListItems(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: ASSETService_ListItems_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ASSETServiceServer).ListItems(ctx, req.(*ListItemsRequest))
	}
	return interceptor(ctx, in, info, handler)
}

// ASSETService_ServiceDesc is the grpc.ServiceDesc for ASSETService service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var ASSETService_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "asset.ASSETService",
	HandlerType: (*ASSETServiceServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "CreateItem",
			Handler:    _ASSETService_CreateItem_Handler,
		},
		{
			MethodName: "GetItem",
			Handler:    _ASSETService_GetItem_Handler,
		},
		{
			MethodName: "UpdateItem",
			Handler:    _ASSETService_UpdateItem_Handler,
		},
		{
			MethodName: "DeleteItem",
			Handler:    _ASSETService_DeleteItem_Handler,
		},
		{
			MethodName: "ListItems",
			Handler:    _ASSETService_ListItems_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "asset.proto",
}
